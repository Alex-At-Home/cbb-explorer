package org.piggottfamily.cbb_explorer.utils.parsers

import scala.util.{Try, Success, Failure}

/** Utilities for managing generation and accumulation of errors */
object ParseUtils {

  /** Puts ids in []s for readability */
  def build_error_id(value: String) = if (value.nonEmpty) s"[$value]" else ""

  /** Builds an either from a request that might throw, returns a list for consistency */
  def build_request[T](location: String, id: String)(request: => T): Either[List[ParseError], T] = Try(request) match {
    case Success(x) => Right(x)
    case Failure(e) => Left(List(ParseError(location, build_error_id(id), s"Exception=[${e.getMessage}]")))
  }
  /** Builds an error with multiple error strings */
  def build_errors(location: String, base_id: String)(subids: String*)(errors: List[String]): ParseError = {
    ParseError(location, (base_id :: subids.toList).map(build_error_id(_)).mkString(""), errors)
  }
  /** Builds an error with a single error strings */
  def build_error(location: String, base_id: String)(subids: String*)(error: String): ParseError = {
    build_errors(location, base_id)(subids:_*)(List(error))
  }

  /** Builds a list of errors with no location info - should be enriched via enrich_error(s) */
  def build_sub_errors(subids: String*)(errors: List[String]): ParseError = {
    build_errors("", "")(subids:_*)(errors)
  }
  /** Builds a single error with no location info - should be enriched via enrich_error(s) */
  def build_sub_error(subids: String*)(error: String): ParseError = {
    build_error("", "")(subids:_*)(error)
  }
  /** Adds top-level location information to a list of sub errors generated by a child */
  def enrich_sub_errors(location: String, base_id: String)(errors: List[ParseError]): List[ParseError] = {
    errors.map(error => ParseError(location, build_error_id(base_id) + error.id, error.messages))
  }
  /** Adds top-level location information to a sub error generated by a child, returns a list for consistency */
  def enrich_sub_error(location: String, base_id: String)(error: ParseError): List[ParseError] = {
    enrich_sub_errors(location, base_id)(List(error))
  }

  /** Lifts errors out of a set of possible errors (2 param) */
  def lift[A, B](a: Either[List[ParseError], A], b: Either[List[ParseError], B]): Either[List[ParseError], (A, B)] = {
    //TODO: tidy up using shapeless
    (a, b) match {
      case (Right(aa), Right(bb)) =>
        Right((aa, bb))
      case _ => // There are errors, so accumulate them
        Left(List(a, b)
          .flatMap(_.left.toOption.toList.flatten)
        )
    }
  }

}
