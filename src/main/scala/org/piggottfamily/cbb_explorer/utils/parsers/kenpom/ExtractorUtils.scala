package org.piggottfamily.cbb_explorer.utils.parsers.kenpom

import org.piggottfamily.cbb_explorer.models._
import org.piggottfamily.cbb_explorer.utils.parsers._
import net.ruippeixotog.scalascraper.browser.JsoupBrowser
import net.ruippeixotog.scalascraper.dsl.DSL._
import net.ruippeixotog.scalascraper.dsl.DSL.Extract._
import net.ruippeixotog.scalascraper.dsl.DSL.Parse._
import net.ruippeixotog.scalascraper.model._
import cats.implicits._
import cats.data._
import com.github.dwickern.macros.NameOf._
import shapeless._
import ops.hlist._
import shapeless.labelled._
import record._
import ops.record._
import syntax.singleton._

/** Semi-generic HTML extraction logic and poly mappers */
object ExtractorUtils {

  /** Error enrichment placeholder */
  val `parent_fills_in` = ""

  /** Enriches errors generated by child functions (single error) */
  def single_error_enricher(field: String) = ParseUtils.enrich_sub_error(`parent_fills_in`, field) _
  /** Enriches errors generated by child functions (multiple errors) */
  def multi_error_enricher(field: String) = ParseUtils.enrich_sub_errors(`parent_fills_in`, field) _

  // Extractor models for which poly mapper support exists

  /** Pulls out metrics from the scripts used to inject into the HTML page */
  case class ScriptMetricExtractor(path: String)

  /** Pulls fields out from any HTML doc and builds into an object or error */
  case class HtmlExtractor[T](
    extract: Element => Option[Element],
    build: Element => Either[ParseError, T],
    fallback: Option[T] = None
  )

  /** Pulls "metrics elements" into metrics from HTML */
  case class HtmlMetricExtractor(
    extract: Element => Option[Element]
  )
  /** Performs non-recursive extraction of child fields that can be any of the above extractors */
  case class ChildExtractor[I <: HList, T](
    fields: I,
    model_builder: LabelledGeneric[T] //(unused except to provide the type T)
  )

  // Poly mappers for the different extractor models

  /** HList mapper for converting semi-pre-parsed script metric fields */
  trait ScriptMetricExtractorMapper extends Poly1 {
    val map: Map[String, Either[ParseError, Document]]

    private def parse_stats_map(in: Option[Either[ParseError, Document]]): Either[List[ParseError], Metric] = {
      in.map(_.map(Some(_))).getOrElse(Right(None)) //(swap the option and either)
        .left.map(List(_))
        .flatMap(d => get_metric(d.map(_.body)))
    }
    implicit def script_metric_fields[K <: Symbol](implicit key: Witness.Aux[K]) =
      at[FieldType[K, ScriptMetricExtractor]](kv => {
        val extractor: ScriptMetricExtractor = kv
        field[K](
          parse_stats_map(map.get(extractor.path))
            .left.map(multi_error_enricher(key.value.name))
        ) //(returns FieldType[K, Either[List[ParseError], Metric])
      })
  }
  /** HList mapper for converting HTML fields */
  trait HtmlExtractorMapper extends Poly1 {
    val root: Element

    implicit def html_fields[K <: Symbol, T](implicit key: Witness.Aux[K]) =
      at[FieldType[K, HtmlExtractor[T]]](kv => {
        val extractor: HtmlExtractor[T] = kv
        field[K](
          parse_html(root, extractor, key.value.name)
        ) //(returns FieldType[K, Either[List[ParseError], T])
      })
  }
  /** HList mapper for converting HTML fields */
  trait HtmlMetricExtractorMapper extends Poly1 {
    val root: Element

    implicit def html_metric_fields[K <: Symbol, T](implicit key: Witness.Aux[K]) =
      at[FieldType[K, HtmlMetricExtractor]](kv => {
        val extractor: HtmlMetricExtractor = kv
        field[K](
          get_metric(extractor.extract(root))
            .left.map(multi_error_enricher(key.value.name))
        ) //(returns FieldType[K, Either[List[ParseError], Metric])
      })
  }

  /** Internal component for HList mapper that maps over nested HLists */
  trait NonRecursiveChildExtractorMapper
    extends Poly1
    with ScriptMetricExtractorMapper
    with HtmlExtractorMapper
    with HtmlMetricExtractorMapper

  /** HList mapper that maps over nested HLists */
  trait ChildExtractorMapper
    extends Poly1
    with NonRecursiveChildExtractorMapper
  {
    val myself = this
    object child_extractor extends NonRecursiveChildExtractorMapper {
      //(in theory should be able to use "this". but can't get it working in practice)
      override val map = myself.map
      override val root = myself.root
    }

    implicit def children_fields
      [K <: Symbol, I <: HList, M1 <: HList, M2 <: HList, R <: HList, O]
      (implicit
        key: Witness.Aux[K],
        ogen: LabelledGeneric.Aux[O, R],
        child_mapper: Mapper.Aux[child_extractor.type, I, M1],
        // (need to bring in all the impplicits from ParseUtils.sequence_kv_results):
        right_only_mapper: Mapper.Aux[ParseUtils.right_only_kv.type, M1, R],
        left_or_filter_right_mapper: Mapper.Aux[ParseUtils.left_or_filter_right_kv.type, M1, M2],
        to_list: ToTraversable.Aux[M2, List, List[ParseError]]
      ) = at[FieldType[K, ChildExtractor[I, O]]](kv => {
        val extractor: ChildExtractor[I, O] = kv

        field[K](
          ParseUtils.sequence_kv_results(
            extractor.fields map child_extractor
          ).left.map(multi_error_enricher(key.value.name))
          .right.map(ogen.from(_))
        )//returns Either[List[ParseError], O]
      })
  }

  // Utility methods required by the mappers

  /** Invokes and HTML extractor and AnyVal/case class buider and wraps with errors */
  def parse_html[T](el: Element, extractor: HtmlExtractor[T], fieldname: String)
  : Either[ParseError, T] =
  {
    extractor.extract(el) match {
      case Some(result) =>
        extractor.build(result)
      case None if extractor.fallback.isDefined =>
        Right(extractor.fallback.get)      
      case None =>
        Left(ParseUtils.build_sub_error(fieldname)(
          s"Failed to parse HTML - couldn't extract [$fieldname] context [$el]"
        ))
    }
  }

  /** Pulls out the rank and score from the format consistently used in HTML fragments */
  def get_metric(sub_doc: Option[Element]): Either[List[ParseError], Metric] =
  {
    def add_context(context: String)(error: ParseError): ParseError = {
      error.copy(messages = error.messages.map(_ + s" context=[$context]"))
    }
    val root: Either[List[ParseError], Unit] = Right(())
    sub_doc match {
      case Some(html) => for {
        _ <- root

        score_or_error =
          ParseUtils.parse_score((html >?> element("a")).map(_.text))
          .left.map(add_context(html.outerHtml))
          .left.map(List(_))
        rank_or_error =
          ParseUtils.parse_rank((html >?> element("span[class=seed]")).map(_.text))
          .left.map(add_context(html.outerHtml))
          .left.map(List(_))

        score_rank <- (score_or_error, rank_or_error).parMapN((_, _))
        (score, rank) = score_rank

      } yield Metric(score, rank)

      case None =>
        Left(List(ParseUtils.build_sub_error(nameOf[Metric](_.value))(
          s"Failed to locate the field"
        )))
    }
  }

}
